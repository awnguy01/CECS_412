
TinyOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800100  000003ba  0000044e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  008001d0  008001d0  0000051e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000051e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000550  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  00000590  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000bc3  00000000  00000000  00000610  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000700  00000000  00000000  000011d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000069b  00000000  00000000  000018d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000c8  00000000  00000000  00001f70  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002dfd  00000000  00000000  00002038  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000f7  00000000  00000000  00004e35  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  00004f2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00000a5f  00000000  00000000  00004f7c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
   2:	00 00       	nop
   4:	4c c0       	rjmp	.+152    	; 0x9e <__bad_interrupt>
   6:	00 00       	nop
   8:	4a c0       	rjmp	.+148    	; 0x9e <__bad_interrupt>
   a:	00 00       	nop
   c:	48 c0       	rjmp	.+144    	; 0x9e <__bad_interrupt>
   e:	00 00       	nop
  10:	46 c0       	rjmp	.+140    	; 0x9e <__bad_interrupt>
  12:	00 00       	nop
  14:	44 c0       	rjmp	.+136    	; 0x9e <__bad_interrupt>
  16:	00 00       	nop
  18:	42 c0       	rjmp	.+132    	; 0x9e <__bad_interrupt>
  1a:	00 00       	nop
  1c:	40 c0       	rjmp	.+128    	; 0x9e <__bad_interrupt>
  1e:	00 00       	nop
  20:	3e c0       	rjmp	.+124    	; 0x9e <__bad_interrupt>
  22:	00 00       	nop
  24:	3c c0       	rjmp	.+120    	; 0x9e <__bad_interrupt>
  26:	00 00       	nop
  28:	3a c0       	rjmp	.+116    	; 0x9e <__bad_interrupt>
  2a:	00 00       	nop
  2c:	38 c0       	rjmp	.+112    	; 0x9e <__bad_interrupt>
  2e:	00 00       	nop
  30:	36 c0       	rjmp	.+108    	; 0x9e <__bad_interrupt>
  32:	00 00       	nop
  34:	34 c0       	rjmp	.+104    	; 0x9e <__bad_interrupt>
  36:	00 00       	nop
  38:	32 c0       	rjmp	.+100    	; 0x9e <__bad_interrupt>
  3a:	00 00       	nop
  3c:	30 c0       	rjmp	.+96     	; 0x9e <__bad_interrupt>
  3e:	00 00       	nop
  40:	2e c0       	rjmp	.+92     	; 0x9e <__bad_interrupt>
  42:	00 00       	nop
  44:	2c c0       	rjmp	.+88     	; 0x9e <__bad_interrupt>
  46:	00 00       	nop
  48:	2a c0       	rjmp	.+84     	; 0x9e <__bad_interrupt>
  4a:	00 00       	nop
  4c:	28 c0       	rjmp	.+80     	; 0x9e <__bad_interrupt>
  4e:	00 00       	nop
  50:	26 c0       	rjmp	.+76     	; 0x9e <__bad_interrupt>
  52:	00 00       	nop
  54:	24 c0       	rjmp	.+72     	; 0x9e <__bad_interrupt>
  56:	00 00       	nop
  58:	22 c0       	rjmp	.+68     	; 0x9e <__bad_interrupt>
  5a:	00 00       	nop
  5c:	20 c0       	rjmp	.+64     	; 0x9e <__bad_interrupt>
  5e:	00 00       	nop
  60:	1e c0       	rjmp	.+60     	; 0x9e <__bad_interrupt>
  62:	00 00       	nop
  64:	1c c0       	rjmp	.+56     	; 0x9e <__bad_interrupt>
	...

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ea eb       	ldi	r30, 0xBA	; 186
  7c:	f3 e0       	ldi	r31, 0x03	; 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <DIDR1+0x5>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 3d       	cpi	r26, 0xD0	; 208
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <DIDR1+0x1>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a0 ed       	ldi	r26, 0xD0	; 208
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ab 3d       	cpi	r26, 0xDB	; 219
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	62 d1       	rcall	.+708    	; 0x360 <main>
  9c:	8c c1       	rjmp	.+792    	; 0x3b6 <_exit>

0000009e <__bad_interrupt>:
  9e:	b0 cf       	rjmp	.-160    	; 0x0 <__vectors>

000000a0 <Mega328P_Init>:
.set	temp,0				//student comment here

.section ".text"			//student comment here
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  a0:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		//student comment here
  a2:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			//student comment here
  a4:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		//student comment here
  a6:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
  a8:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			//student comment here
  aa:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		//student comment here
  ac:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		//student comment here
  ae:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts	UBRR0L,r16		//student comment here
  b2:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ldi	r16,24			//student comment here
  b6:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		//student comment here
  b8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		ldi	r16,6			//student comment here
  bc:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		//student comment here
  be:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		ldi r16,0x87		//initialize ADC
  c2:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		//student comment here
  c4:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		ldi r16,0x40		//student comment here
  c8:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		//student comment here
  ca:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
		ldi r16,0			//student comment here
  ce:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		//student comment here
  d0:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		ldi r16,0xFE		//student comment here
  d4:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		//student comment here
  d6:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
		ldi r16,0xFF		//student comment here
  da:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		//student comment here
  dc:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
		ret					//student comment here
  e0:	08 95       	ret

000000e2 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		//student comment here
  e2:	31 d0       	rcall	.+98     	; 0x146 <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
  e4:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
  e6:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
  e8:	00 91 d0 01 	lds	r16, 0x01D0	; 0x8001d0 <__data_end>
	out		PORTD,r16		//student comment here
  ec:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			//student comment here
  ee:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		//student comment here
	call	LCD_Delay		//student comment here
  f0:	05 b9       	out	0x05, r16	; 5
  f2:	04 d0       	rcall	.+8      	; 0xfc <LCD_Delay>
	ldi		r16,0			//student comment here
	out		PORTB,r16		//student comment here
	call	LCD_Delay		//student comment here
  f4:	00 e0       	ldi	r16, 0x00	; 0
  f6:	05 b9       	out	0x05, r16	; 5
	call	UART_On			//student comment here
  f8:	01 d0       	rcall	.+2      	; 0xfc <LCD_Delay>
  fa:	1f c0       	rjmp	.+62     	; 0x13a <UART_On>

000000fc <LCD_Delay>:
	ret						//student comment here
  fc:	0a ef       	ldi	r16, 0xFA	; 250

000000fe <D0>:

LCD_Delay:
	ldi		r16,0xFA		//student comment here
  fe:	1f ef       	ldi	r17, 0xFF	; 255

00000100 <D1>:
D0:	ldi		r17,0xFF		//student comment here
 100:	1a 95       	dec	r17
D1:	dec		r17				//student comment here
 102:	f1 f7       	brne	.-4      	; 0x100 <D1>
	brne	D1				//student comment here
	dec		r16				//student comment here
 104:	0a 95       	dec	r16
	brne	D0				//student comment here
 106:	d9 f7       	brne	.-10     	; 0xfe <D0>
	ret						//student comment here
 108:	08 95       	ret

0000010a <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		//student comment here
 10a:	1d d0       	rcall	.+58     	; 0x146 <UART_Off>
 10c:	0f ef       	ldi	r16, 0xFF	; 255
	ldi		r16,0xFF		//student comment here
 10e:	0a b9       	out	0x0a, r16	; 10
	out		DDRD,r16		//student comment here
 110:	00 91 d0 01 	lds	r16, 0x01D0	; 0x8001d0 <__data_end>
	lds		r16,DATA		//student comment here
	out		PORTD,r16		//student comment here
 114:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			//student comment here
	out		PORTB,r16		//student comment here
	call	LCD_Delay		//student comment here
 116:	06 e0       	ldi	r16, 0x06	; 6
	ldi		r16,0			//student comment here
 118:	05 b9       	out	0x05, r16	; 5
	out		PORTB,r16		//student comment here
 11a:	f0 df       	rcall	.-32     	; 0xfc <LCD_Delay>
	call	LCD_Delay		//student comment here
 11c:	00 e0       	ldi	r16, 0x00	; 0
 11e:	05 b9       	out	0x05, r16	; 5
	call	UART_On			//student comment here
 120:	ed df       	rcall	.-38     	; 0xfc <LCD_Delay>
 122:	0b c0       	rjmp	.+22     	; 0x13a <UART_On>
	ret						//student comment here
 124:	08 95       	ret

00000126 <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		//student comment here
 126:	0f d0       	rcall	.+30     	; 0x146 <UART_Off>
	ldi		r16,0x00		//student comment here
 128:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		//student comment here
 12a:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			//student comment here
 12c:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		//student comment here
 12e:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		//student comment here
 130:	00 93 d0 01 	sts	0x01D0, r16	; 0x8001d0 <__data_end>
	out		PORTB,0			//student comment here
 134:	05 b8       	out	0x05, r0	; 5
	call	UART_On			//student comment here
 136:	01 c0       	rjmp	.+2      	; 0x13a <UART_On>
 138:	08 95       	ret

0000013a <UART_On>:
	ret						//student comment here
 13a:	02 e0       	ldi	r16, 0x02	; 2

.global UART_On
UART_On:
	ldi		r16,2				//student comment here
 13c:	0a b9       	out	0x0a, r16	; 10
	out		DDRD,r16			//student comment here
 13e:	08 e1       	ldi	r16, 0x18	; 24
	ldi		r16,24				//student comment here
 140:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	sts		UCSR0B,r16			//student comment here
 144:	08 95       	ret

00000146 <UART_Off>:
	ret							//student comment here
 146:	00 e0       	ldi	r16, 0x00	; 0

.global UART_Off
UART_Off:
	ldi	r16,0					//student comment here
 148:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	sts UCSR0B,r16				//student comment here
 14c:	08 95       	ret

0000014e <UART_Clear>:
	ret							//student comment here
 14e:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			//student comment here
 152:	07 ff       	sbrs	r16, 7
	sbrs	r16,RXC0			//student comment here
 154:	08 95       	ret
	ret							//student comment here
 156:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	lds		r16,UDR0			//student comment here
 15a:	f9 cf       	rjmp	.-14     	; 0x14e <UART_Clear>

0000015c <UART_Get>:
	rjmp	UART_Clear			//student comment here
 15c:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			//student comment here
 160:	07 ff       	sbrs	r16, 7
	sbrs	r16,RXC0			//student comment here
 162:	fc cf       	rjmp	.-8      	; 0x15c <UART_Get>
	rjmp	UART_Get			//student comment here
 164:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	lds		r16,UDR0			//student comment here
 168:	00 93 d2 01 	sts	0x01D2, r16	; 0x8001d2 <ASCII>
	sts		ASCII,r16			//student comment here
 16c:	08 95       	ret

0000016e <UART_Put>:
	ret							//student comment here
 16e:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>

.global UART_Put
UART_Put:
	lds		r17,UCSR0A			//student comment here
 172:	15 ff       	sbrs	r17, 5
	sbrs	r17,UDRE0			//student comment here
 174:	fc cf       	rjmp	.-8      	; 0x16e <UART_Put>
	rjmp	UART_Put			//student comment here
 176:	00 91 d2 01 	lds	r16, 0x01D2	; 0x8001d2 <ASCII>
	lds		r16,ASCII			//student comment here
 17a:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		UDR0,r16			//student comment here
 17e:	08 95       	ret

00000180 <ADC_Get>:
	ret							//student comment here
 180:	07 ec       	ldi	r16, 0xC7	; 199

.global ADC_Get
ADC_Get:
		ldi		r16,0xC7			//student comment here
 182:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

00000186 <A2V1>:
		sts		ADCSRA,r16			//student comment here
 186:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
A2V1:	lds		r16,ADCSRA			//student comment here
 18a:	06 fd       	sbrc	r16, 6
		sbrc	r16,ADSC			//student comment here
 18c:	fc cf       	rjmp	.-8      	; 0x186 <A2V1>
		rjmp 	A2V1				//student comment here
 18e:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		lds		r16,ADCL			//student comment here
 192:	00 93 d8 01 	sts	0x01D8, r16	; 0x8001d8 <LADC>
		sts		LADC,r16			//student comment here
 196:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		lds		r16,ADCH			//student comment here
 19a:	00 93 d1 01 	sts	0x01D1, r16	; 0x8001d1 <HADC>
		sts		HADC,r16			//student comment here
 19e:	08 95       	ret

000001a0 <EEPROM_Write>:
		ret							//student comment here
 1a0:	f9 99       	sbic	0x1f, 1	; 31

.global EEPROM_Write
EEPROM_Write:      
		sbic    EECR,EEPE
 1a2:	fe cf       	rjmp	.-4      	; 0x1a0 <EEPROM_Write>
		rjmp    EEPROM_Write		; Wait for completion of previous write
 1a4:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r18,0x00			; Set up address (r18:r17) in address register
 1a6:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r17,0x05 
 1a8:	06 e4       	ldi	r16, 0x46	; 70
		ldi		r16,'F'				; Set up data in r16    
 1aa:	22 bd       	out	0x22, r18	; 34
		out     EEARH, r18      
 1ac:	11 bd       	out	0x21, r17	; 33
		out     EEARL, r17			      
 1ae:	00 bd       	out	0x20, r16	; 32
		out     EEDR,r16			; Write data (r16) to Data Register  
 1b0:	fa 9a       	sbi	0x1f, 2	; 31
		sbi     EECR,EEMPE			; Write logical one to EEMPE
 1b2:	f9 9a       	sbi	0x1f, 1	; 31
		sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 1b4:	08 95       	ret

000001b6 <EEPROM_Read>:
		ret 
 1b6:	f9 99       	sbic	0x1f, 1	; 31

.global EEPROM_Read
EEPROM_Read:					    
		sbic    EECR,EEPE    
 1b8:	fe cf       	rjmp	.-4      	; 0x1b6 <EEPROM_Read>
		rjmp    EEPROM_Read		; Wait for completion of previous write
 1ba:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r18,0x00		; Set up address (r18:r17) in EEPROM address register
 1bc:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r17,0x05
 1be:	00 e0       	ldi	r16, 0x00	; 0
		ldi		r16,0x00   
 1c0:	22 bd       	out	0x22, r18	; 34
		out     EEARH, r18   
 1c2:	11 bd       	out	0x21, r17	; 33
		out     EEARL, r17		   
 1c4:	f8 9a       	sbi	0x1f, 0	; 31
		sbi     EECR,EERE		; Start eeprom read by writing EERE
 1c6:	00 b5       	in	r16, 0x20	; 32
		in      r16,EEDR		; Read data from Data Register
 1c8:	00 93 d2 01 	sts	0x01D2, r16	; 0x8001d2 <ASCII>
		sts		ASCII,r16  
 1cc:	08 95       	ret

000001ce <UART_Puts>:

char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 1ce:	cf 93       	push	r28
 1d0:	df 93       	push	r29
 1d2:	ec 01       	movw	r28, r24
	while (*str)
 1d4:	98 81       	ld	r25, Y
 1d6:	99 23       	and	r25, r25
 1d8:	39 f0       	breq	.+14     	; 0x1e8 <UART_Puts+0x1a>
 1da:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;
 1dc:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <ASCII>
		UART_Put();
 1e0:	c6 df       	rcall	.-116    	; 0x16e <UART_Put>
char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)
 1e2:	99 91       	ld	r25, Y+
 1e4:	91 11       	cpse	r25, r1
 1e6:	fa cf       	rjmp	.-12     	; 0x1dc <UART_Puts+0xe>
	{
		ASCII = *str++;
		UART_Put();
	}
}
 1e8:	df 91       	pop	r29
 1ea:	cf 91       	pop	r28
 1ec:	08 95       	ret

000001ee <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 1ee:	cf 93       	push	r28
 1f0:	df 93       	push	r29
 1f2:	ec 01       	movw	r28, r24
	while (*str)
 1f4:	98 81       	ld	r25, Y
 1f6:	99 23       	and	r25, r25
 1f8:	39 f0       	breq	.+14     	; 0x208 <LCD_Puts+0x1a>
 1fa:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 1fc:	90 93 d0 01 	sts	0x01D0, r25	; 0x8001d0 <__data_end>
		LCD_Write_Data();
 200:	84 df       	rcall	.-248    	; 0x10a <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 202:	99 91       	ld	r25, Y+
 204:	91 11       	cpse	r25, r1
 206:	fa cf       	rjmp	.-12     	; 0x1fc <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 208:	df 91       	pop	r29
 20a:	cf 91       	pop	r28
 20c:	08 95       	ret

0000020e <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 20e:	82 eb       	ldi	r24, 0xB2	; 178
 210:	91 e0       	ldi	r25, 0x01	; 1
 212:	dd df       	rcall	.-70     	; 0x1ce <UART_Puts>
	UART_Puts(MS2);
 214:	8b e7       	ldi	r24, 0x7B	; 123
 216:	91 e0       	ldi	r25, 0x01	; 1
 218:	da df       	rcall	.-76     	; 0x1ce <UART_Puts>
	UART_Puts(MS4);
 21a:	80 e5       	ldi	r24, 0x50	; 80
 21c:	91 e0       	ldi	r25, 0x01	; 1
 21e:	d7 cf       	rjmp	.-82     	; 0x1ce <UART_Puts>
 220:	08 95       	ret

00000222 <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 222:	8a e5       	ldi	r24, 0x5A	; 90
 224:	91 e0       	ldi	r25, 0x01	; 1
 226:	d3 cf       	rjmp	.-90     	; 0x1ce <UART_Puts>
 228:	08 95       	ret

0000022a <LCD>:
}

void LCD(void)						//Lite LCD demo
{
	DATA = 0x34;					//Student Comment Here
 22a:	84 e3       	ldi	r24, 0x34	; 52
 22c:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 230:	58 df       	rcall	.-336    	; 0xe2 <LCD_Write_Command>
	DATA = 0x08;					//Student Comment Here
 232:	88 e0       	ldi	r24, 0x08	; 8
 234:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 238:	54 df       	rcall	.-344    	; 0xe2 <LCD_Write_Command>
	DATA = 0x02;					//Student Comment Here
 23a:	82 e0       	ldi	r24, 0x02	; 2
 23c:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 240:	50 df       	rcall	.-352    	; 0xe2 <LCD_Write_Command>
	DATA = 0x06;					//Student Comment Here
 242:	86 e0       	ldi	r24, 0x06	; 6
 244:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
	DATA = 0x0f;					//Student Comment Here
 248:	4c df       	rcall	.-360    	; 0xe2 <LCD_Write_Command>
 24a:	8f e0       	ldi	r24, 0x0F	; 15
	LCD_Write_Command();
 24c:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Puts("Hello ECE412!");
 250:	48 df       	rcall	.-368    	; 0xe2 <LCD_Write_Command>
 252:	80 e0       	ldi	r24, 0x00	; 0
 254:	91 e0       	ldi	r25, 0x01	; 1
 256:	cb cf       	rjmp	.-106    	; 0x1ee <LCD_Puts>
 258:	08 95       	ret

0000025a <ADC>:
	always be able to return to command line.
	*/
}

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 25a:	cf 93       	push	r28
 25c:	df 93       	push	r29
	volts[0x1]='.';
 25e:	c3 ed       	ldi	r28, 0xD3	; 211
 260:	d1 e0       	ldi	r29, 0x01	; 1
 262:	8e e2       	ldi	r24, 0x2E	; 46
 264:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';
 266:	80 e2       	ldi	r24, 0x20	; 32
 268:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;
 26a:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();
 26c:	89 df       	rcall	.-238    	; 0x180 <ADC_Get>
	Acc = (((int)HADC) * 0x100 + (int)(LADC))*0xA;
 26e:	20 91 d1 01 	lds	r18, 0x01D1	; 0x8001d1 <HADC>
 272:	02 2e       	mov	r0, r18
 274:	00 0c       	add	r0, r0
 276:	33 0b       	sbc	r19, r19
 278:	32 2f       	mov	r19, r18
 27a:	22 27       	eor	r18, r18
 27c:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <LADC>
 280:	28 0f       	add	r18, r24
 282:	31 1d       	adc	r19, r1
 284:	87 fd       	sbrc	r24, 7
 286:	3a 95       	dec	r19
 288:	c9 01       	movw	r24, r18
 28a:	88 0f       	add	r24, r24
 28c:	99 1f       	adc	r25, r25
 28e:	22 0f       	add	r18, r18
 290:	33 1f       	adc	r19, r19
 292:	22 0f       	add	r18, r18
 294:	33 1f       	adc	r19, r19
 296:	22 0f       	add	r18, r18
 298:	33 1f       	adc	r19, r19
 29a:	82 0f       	add	r24, r18
 29c:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);
 29e:	ee ef       	ldi	r30, 0xFE	; 254
 2a0:	f7 e0       	ldi	r31, 0x07	; 7
 2a2:	bf 01       	movw	r22, r30
 2a4:	61 d0       	rcall	.+194    	; 0x368 <__divmodhi4>
 2a6:	26 2f       	mov	r18, r22
 2a8:	30 e3       	ldi	r19, 0x30	; 48
 2aa:	36 0f       	add	r19, r22
 2ac:	38 83       	st	Y, r19
	Acc = Acc % 0x7FE;
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;
 2ae:	ac 01       	movw	r20, r24
 2b0:	44 0f       	add	r20, r20
 2b2:	55 1f       	adc	r21, r21
 2b4:	88 0f       	add	r24, r24
 2b6:	99 1f       	adc	r25, r25
 2b8:	88 0f       	add	r24, r24
 2ba:	99 1f       	adc	r25, r25
 2bc:	88 0f       	add	r24, r24
 2be:	99 1f       	adc	r25, r25
 2c0:	84 0f       	add	r24, r20
 2c2:	95 1f       	adc	r25, r21
 2c4:	bf 01       	movw	r22, r30
 2c6:	50 d0       	rcall	.+160    	; 0x368 <__divmodhi4>
 2c8:	30 e3       	ldi	r19, 0x30	; 48
 2ca:	36 0f       	add	r19, r22
 2cc:	3a 83       	std	Y+2, r19	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;
 2ce:	90 93 da 01 	sts	0x01DA, r25	; 0x8001da <Acc+0x1>
 2d2:	80 93 d9 01 	sts	0x01D9, r24	; 0x8001d9 <Acc>
	if (Acc >= 0x3FF) volts[0x2]++;
 2d6:	8f 3f       	cpi	r24, 0xFF	; 255
 2d8:	93 40       	sbci	r25, 0x03	; 3
 2da:	1c f0       	brlt	.+6      	; 0x2e2 <ADC+0x88>
 2dc:	6f 5c       	subi	r22, 0xCF	; 207
 2de:	60 93 d5 01 	sts	0x01D5, r22	; 0x8001d5 <volts+0x2>
	if (volts[0x2] == 58)
 2e2:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <volts+0x2>
 2e6:	8a 33       	cpi	r24, 0x3A	; 58
 2e8:	31 f4       	brne	.+12     	; 0x2f6 <ADC+0x9c>
	{
		volts[0x2] = 48;
 2ea:	e3 ed       	ldi	r30, 0xD3	; 211
 2ec:	f1 e0       	ldi	r31, 0x01	; 1
 2ee:	80 e3       	ldi	r24, 0x30	; 48
 2f0:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;
 2f2:	2f 5c       	subi	r18, 0xCF	; 207
	}
	UART_Puts(volts);
 2f4:	20 83       	st	Z, r18
 2f6:	83 ed       	ldi	r24, 0xD3	; 211
 2f8:	91 e0       	ldi	r25, 0x01	; 1
	UART_Puts(MS6);
 2fa:	69 df       	rcall	.-302    	; 0x1ce <UART_Puts>
 2fc:	8a e2       	ldi	r24, 0x2A	; 42
 2fe:	91 e0       	ldi	r25, 0x01	; 1
 300:	66 df       	rcall	.-308    	; 0x1ce <UART_Puts>
		The potentiometer simulates a thermistor, its varying resistance simulates the
		varying resistance of a thermistor as it is heated and cooled. See the thermistor
		equations in the lab 3 folder. User must always be able to return to command line.
	*/
	
}
 302:	df 91       	pop	r29
 304:	cf 91       	pop	r28
 306:	08 95       	ret

00000308 <EEPROM>:

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM Write and Read.");
 308:	8e e0       	ldi	r24, 0x0E	; 14
 30a:	91 e0       	ldi	r25, 0x01	; 1
 30c:	60 df       	rcall	.-320    	; 0x1ce <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\n");
 30e:	87 e2       	ldi	r24, 0x27	; 39
 310:	91 e0       	ldi	r25, 0x01	; 1
	EEPROM_Write();
 312:	5d df       	rcall	.-326    	; 0x1ce <UART_Puts>
	UART_Puts("\r\n");
 314:	45 df       	rcall	.-374    	; 0x1a0 <EEPROM_Write>
 316:	87 e2       	ldi	r24, 0x27	; 39
	EEPROM_Read();
 318:	91 e0       	ldi	r25, 0x01	; 1
	UART_Put();
 31a:	59 df       	rcall	.-334    	; 0x1ce <UART_Puts>
 31c:	4c df       	rcall	.-360    	; 0x1b6 <EEPROM_Read>
	UART_Puts("\r\n");
 31e:	27 df       	rcall	.-434    	; 0x16e <UART_Put>
 320:	87 e2       	ldi	r24, 0x27	; 39
 322:	91 e0       	ldi	r25, 0x01	; 1
 324:	54 cf       	rjmp	.-344    	; 0x1ce <UART_Puts>
 326:	08 95       	ret

00000328 <Command>:
}


void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 328:	8a e5       	ldi	r24, 0x5A	; 90
 32a:	91 e0       	ldi	r25, 0x01	; 1
 32c:	50 df       	rcall	.-352    	; 0x1ce <UART_Puts>
	ASCII = '\0';						
 32e:	10 92 d2 01 	sts	0x01D2, r1	; 0x8001d2 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 332:	14 df       	rcall	.-472    	; 0x15c <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 334:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <ASCII>
 338:	88 23       	and	r24, r24
 33a:	d9 f3       	breq	.-10     	; 0x332 <Command+0xa>
	{
		UART_Get();
	}
	switch (ASCII)
 33c:	85 36       	cpi	r24, 0x65	; 101
 33e:	49 f0       	breq	.+18     	; 0x352 <Command+0x2a>
 340:	8c 36       	cpi	r24, 0x6C	; 108
 342:	19 f0       	breq	.+6      	; 0x34a <Command+0x22>
 344:	81 36       	cpi	r24, 0x61	; 97
 346:	39 f4       	brne	.+14     	; 0x356 <Command+0x2e>
	{
		case 'L' | 'l': LCD();
 348:	02 c0       	rjmp	.+4      	; 0x34e <Command+0x26>
		break;
		case 'A' | 'a': ADC();
 34a:	6f cf       	rjmp	.-290    	; 0x22a <LCD>
 34c:	08 95       	ret
		break;
 34e:	85 cf       	rjmp	.-246    	; 0x25a <ADC>
		case 'E' | 'e': EEPROM();
 350:	08 95       	ret
		break;
 352:	da cf       	rjmp	.-76     	; 0x308 <EEPROM>
		default:
		UART_Puts(MS5);
 354:	08 95       	ret
 356:	81 e3       	ldi	r24, 0x31	; 49
 358:	91 e0       	ldi	r25, 0x01	; 1
 35a:	39 df       	rcall	.-398    	; 0x1ce <UART_Puts>
		HELP();
 35c:	62 cf       	rjmp	.-316    	; 0x222 <HELP>
 35e:	08 95       	ret

00000360 <main>:
 360:	9f de       	rcall	.-706    	; 0xa0 <Mega328P_Init>
}

int main(void)
{
	Mega328P_Init();
	Banner();
 362:	55 df       	rcall	.-342    	; 0x20e <Banner>
	while (1)
	{
		Command();				//infinite command loop
 364:	e1 df       	rcall	.-62     	; 0x328 <Command>
 366:	fe cf       	rjmp	.-4      	; 0x364 <main+0x4>

00000368 <__divmodhi4>:
 368:	97 fb       	bst	r25, 7
 36a:	07 2e       	mov	r0, r23
 36c:	16 f4       	brtc	.+4      	; 0x372 <__divmodhi4+0xa>
 36e:	00 94       	com	r0
 370:	06 d0       	rcall	.+12     	; 0x37e <__divmodhi4_neg1>
 372:	77 fd       	sbrc	r23, 7
 374:	08 d0       	rcall	.+16     	; 0x386 <__divmodhi4_neg2>
 376:	0b d0       	rcall	.+22     	; 0x38e <__udivmodhi4>
 378:	07 fc       	sbrc	r0, 7
 37a:	05 d0       	rcall	.+10     	; 0x386 <__divmodhi4_neg2>
 37c:	3e f4       	brtc	.+14     	; 0x38c <__divmodhi4_exit>

0000037e <__divmodhi4_neg1>:
 37e:	90 95       	com	r25
 380:	81 95       	neg	r24
 382:	9f 4f       	sbci	r25, 0xFF	; 255
 384:	08 95       	ret

00000386 <__divmodhi4_neg2>:
 386:	70 95       	com	r23
 388:	61 95       	neg	r22
 38a:	7f 4f       	sbci	r23, 0xFF	; 255

0000038c <__divmodhi4_exit>:
 38c:	08 95       	ret

0000038e <__udivmodhi4>:
 38e:	aa 1b       	sub	r26, r26
 390:	bb 1b       	sub	r27, r27
 392:	51 e1       	ldi	r21, 0x11	; 17
 394:	07 c0       	rjmp	.+14     	; 0x3a4 <__udivmodhi4_ep>

00000396 <__udivmodhi4_loop>:
 396:	aa 1f       	adc	r26, r26
 398:	bb 1f       	adc	r27, r27
 39a:	a6 17       	cp	r26, r22
 39c:	b7 07       	cpc	r27, r23
 39e:	10 f0       	brcs	.+4      	; 0x3a4 <__udivmodhi4_ep>
 3a0:	a6 1b       	sub	r26, r22
 3a2:	b7 0b       	sbc	r27, r23

000003a4 <__udivmodhi4_ep>:
 3a4:	88 1f       	adc	r24, r24
 3a6:	99 1f       	adc	r25, r25
 3a8:	5a 95       	dec	r21
 3aa:	a9 f7       	brne	.-22     	; 0x396 <__udivmodhi4_loop>
 3ac:	80 95       	com	r24
 3ae:	90 95       	com	r25
 3b0:	bc 01       	movw	r22, r24
 3b2:	cd 01       	movw	r24, r26
 3b4:	08 95       	ret

000003b6 <_exit>:
 3b6:	f8 94       	cli

000003b8 <__stop_program>:
 3b8:	ff cf       	rjmp	.-2      	; 0x3b8 <__stop_program>
